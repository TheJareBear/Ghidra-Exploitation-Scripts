//Find ROP Gadgets within binaries
//@author Jarod Keene
//@category Exploitation
//@keybinding
//@menupath
//@toolbar

import ghidra.app.plugin.assembler.Assembler;
import ghidra.app.plugin.assembler.Assemblers;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.lang.InstructionBlock;

public class ROPFinder extends GhidraScript {

	@Override
	protected void run() throws Exception {
		// CURRENTLY ASSEMBLES AND SEARCHES FINE, MIGHT FAIL WHEN ALLOWING GAP BYTES, BUT I DIGRESS
		// GOING TO COMPARE AGAINST ROPPER (RELATIVELY GOOD)
		// IDEA: TO FIX THE PADDING BYTE ISSUE, WE COULD RE-DISASSEMBLE AND CONFIRM JUMPS ARE GONE AND OUR INSTRUCTIONS
		// STILL LIVE... MAYBE ROUGH THOUGH. ALSO HAVE TO WATCH FOR DE-REFERENCES
		// ACTUALLY WORKS SOMEWHAT WELL, WAY TOO LIBERAL ON FINDS BUT CAN BE FIXED UP

		// GET GADGET STRING FROM USER
		String gadgetString = askString("Gadget String", "Enter gadget do you want:");
		// GET GADGET INSTRUCTION GAP COUNT
		int gapInstCount = Integer.parseInt(askString("Gap Instruction Count", "What is the maximum gap instruction count for the gadget"));
		// SPLIT THE GADGET STRING INTO EACH INSTRUCTION (BY ;)
		var gadgetParts = gadgetString.toUpperCase().split(";");
		
		// Create assembler to convert listing to bytes
		Assembler asm = Assemblers.getAssembler(currentProgram);
		
		// WALK PORTIONS AND STRIP WHITESPACE
		for(int i = 0; i < gadgetParts.length; i++)
		{
			gadgetParts[i] = gadgetParts[i].strip();
			// MAYBE ASSEMBLE HERE TO BUILD OUT STRING
			// REASONING: WE MAY NEED TO BUILD OUT THE .{0,gapInstCount} BETWEEN INSTRUCTIONS
			// FOR NOW IT IS INCORRECTLY DONE NEAR LINE 59
		}
		
		// Get a copy of the first 100 bytes before we patch
		byte[] beforePatch = new byte[100];
		byte[] afterPatch = new byte[100];
		
		currentProgram.getMemory().getBytes(currentProgram.getImageBase(), beforePatch, 0, 100);
		// Now assemble and patch our gadgetString, if fails, probs a poor instruction
		InstructionBlock patchBlock = null;
		try {
			patchBlock = asm.assemble(currentProgram.getImageBase(), gadgetParts);
		} catch(Exception ex) {
			println("Failed to assemble gadget, maybe mistyped or wrong arch for binary?");
			return;
		}
		
		currentProgram.getMemory().getBytes(currentProgram.getImageBase(), afterPatch, 0, 100);
		
		// NEXT SECTION IS BROKEN AF, GOOD LUCK WRITING TO GHIDRA TRANSACTIONS
		// MAY HAVE TO SET BYTES MANUALLY (ALSO GOOD LUCK SPELLING)
		// ATTEMPT TO SAVE THE PROGRAM (TRANSACTION FOR GHIDRA TO KNOW WRITE IS COMING)
		// var tid = currentProgram.startTransaction("RETURN BYTES TO CORRECT VALUE");
		// Write back the original copied memory
		// currentProgram.getMemory().setBytes(currentProgram.getImageBase(), beforePatch, 0, 100);
		// saveProgram(currentProgram);
		// currentProgram.endTransaction(tid, true);
		
		int gadgetSize = (int)patchBlock.getMaxAddress().subtract(currentProgram.getImageBase()) + 1;
		String gadgetBytes = "";
		String regex = ".{0," + gapInstCount + "}";
		for(int i = 0 ; i < gadgetSize; i++)
		{
			gadgetBytes += String.format("\\x%02x" + regex, afterPatch[i]);
		}
		
		// FIND ALL ADDRESSES THAT HAVE OUR BYTE STRING
		var addresses = findBytes(currentProgram.getImageBase(), gadgetBytes, 100, 1);
				
		// CHECK OUT RESULTS
		if(addresses.length == 0)
		{
			print("No total gadgets found\n");
		}
		else
		{
			for(var a : addresses)
			{
				// DISASSEMBLE BYTES AT THE FOUND ADDRESS TO CONFIRM THAT WE HAVE ALL INSTRUCTIONS WE NEED
				// ACTUALLY SOMEHOW WORKS A LITTLE BIT. KIND OF DOPE
				var tmpAddress = a;
				var currentInstIndex = 0;
				var correctBytesCounter = gadgetSize;
				var limit = 50;
				while(correctBytesCounter > 0 && limit < 1000)
				{
					var inst = getInstructionAt(tmpAddress);
					if(inst == null)
					{
						limit = 0;
						break;
					}
					// COMPARE MNEMONIC AGAINST FIRST PART OF INSTRUCTION
					if(inst.getMnemonicString().contentEquals(gadgetParts[currentInstIndex].split(" ")[0]))
					{
						// SUBTRACT FROM LOOP ELEMENT THE SIZE OF THE CORRECT INSTRUCTION
						correctBytesCounter -= inst.getLength();
						// INCREMENT THE STRING INDEX
						currentInstIndex += 1;
					}
					
					// MOVE OUT ADDRESS ALONG THE NUMBER OF BYTES NECESSARY (NICE WORK ON THIS ONE)
					tmpAddress = tmpAddress.add(inst.getLength());
					// INCREMENT LIMIT
					limit -= 1;
				}
				
				if(limit != 0)
					print("Found gadget at 0x" + a + "\n");
			}
		}
	}
}
