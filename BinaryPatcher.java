//Custom patcher to write shellcode into memory location where desired. So if a user hopes to patch out specific parts of they program with code of their own, this will help.
//@author Jarod Keene
//@category Patcher
//@keybinding
//@menupath
//@toolbar

import java.util.ArrayList;
import java.util.List;

import ghidra.app.plugin.assembler.Assembler;
import ghidra.app.plugin.assembler.Assemblers;
import ghidra.app.script.GhidraScript;
//import ghidra.program.model.lang.InstructionBlock;

public class AssemblyPatcher extends GhidraScript {

	// FUNCTION TO CHANGE HEX STRING TO BYTE ARRAY
	public static byte[] hexStringToByteArray(String s) {
		int len = s.length();
		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
		}
		return data;
	}

	@Override
	protected void run() throws Exception {
		// TODO: ASK USER IF CURRENT LOCATION IS WHERE THEY WANT TO WRITE CODE
		var confirm = askYesNo("Location Confirmation", "Are you sure you want to place code at 0x" + currentAddress);
		if (!confirm) {
			// BREAK IF THEY DON'T CONFIRM THE MEMORY LOCATION
			return;
		}

		// CHECK IF USER WANTS TO WRITE x86 INSTRUCTIONS OR IF THEY HAVE A RAW BYTE
		// STRING TO PATCH
		List<String> choices = new ArrayList<String>();
		choices.add("Code to Assemble");
		choices.add("Raw Byte String");
		var choice = askChoice("Patch Type", "How would you like to patch?", choices, choices.iterator().next());

		// IF THE USER DECIDES TO WRITE CODE THEY WANT ASSEMBLED (IN THE LANGUAGE OF THE
		// CURRENT BINARY)
		if (choice.contentEquals("Code to Assemble")) {
			// ASK FOR CODE TO ASSEMBLE
			var code = askString("Code", "Insert your code here");
			// FIX UP CODE VAR TO BE READY TO ASSEMBLE (SPLIT INTO LIST AND STIP WHITESPACE)
			var codeParts = code.toUpperCase().split(";");
			for (int i = 0; i < codeParts.length; i++)
				codeParts[i] = codeParts[i].strip();
			// SETUP CODE BLOCK TO BE WRITTEN IN TRY BLOCK
			// InstructionBlock writtenBlock = null;
			// CREATE ASSEMBLER VAR TO ASSEMBLE THE CODE GIVEN
			Assembler asm = Assemblers.getAssembler(currentProgram);
			// ATTEMPT TO ASSEMBLE
			try {
				asm.assemble(currentAddress, codeParts);
			} catch (Exception ex) {
				println("Failed to assemble given code. Maybe mistyped or wrong arch for binary?");
				// ex.printStackTrace();
				return;
			}
		} else {
			// ASK FOR ASSEMBLED BYTES (IN FORMAT 5fc39090)
			var code = askString("Byte Insertion", "Insert your assembled bytes here (i.e: 90c3 for nop;ret;)");
			byte[] bytes = hexStringToByteArray(code);
			try {
				clearListing(currentAddress, currentAddress.add(bytes.length-1));
				setBytes(currentAddress, bytes);
				// PROBABLY BETTER WAY TO DO IT, BUT I LIKE MY WAY MORE
				// var tid = currentProgram.startTransaction("patching begin");
				// Assembler asm = Assemblers.getAssembler(currentProgram);
				// asm.patchProgram(bytes, currentAddress);
				// currentProgram.endTransaction(tid, true);
				// IF BYTE PLACEMENT IS SUCCESSFUL, ASK IF THE USER WANTS TO NOW PLACE A LISTING THERE
				var disCheck = askYesNo("Optional Disassembly", "Would you like to treat your bytes as code?");
				if(disCheck)
				{
					// ATTEMPT TO DISASSEMBLE AT THE NEW LOCATION
					disassemble(currentAddress);
				}
			} catch (Exception ex) {
				ex.printStackTrace();
				println("Cannot place bytes in uninitialize memory");
			}
		}
	}
}
