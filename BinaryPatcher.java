//Custom patcher to write shellcode into memory location where desired. So if a user hopes to patch out specific parts of they program with code of their own, this will help.
//@author Jarod Keene
//@category Patcher
//@keybinding
//@menupath
//@toolbar

import java.util.ArrayList;
import java.util.List;

import ghidra.app.plugin.assembler.Assembler;
import ghidra.app.plugin.assembler.Assemblers;
import ghidra.app.script.GhidraScript;

public class BinaryPatcher extends GhidraScript {

	// FUNCTION TO CHANGE HEX STRING TO BYTE ARRAY
	public static byte[] hexStringToByteArray(String s) {
		int len = s.length();
		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
		}
		return data;
	}

	@Override
	protected void run() throws Exception {
		// CONFIRM THAT GHIDRA HAS A CURRENT PROGRAM
		if(currentProgram == null)
		{
			println("Current Program not found, open program to start the patcher!");
			return;
		}

		// ASK USER IF CURRENT LOCATION IS WHERE THEY WANT TO WRITE CODE
		var confirm = askYesNo("Location Confirmation", "Are you sure you want to place code at 0x" + currentAddress);
		if (!confirm) {
			// BREAK IF THEY DON'T CONFIRM THE MEMORY LOCATION
			return;
		}

		// CHECK IF USER WANTS TO WRITE RAW INSTRUCTIONS OR IF THEY HAVE A RAW BYTE
		// STRING TO PATCH
		List<String> choices = new ArrayList<String>();
		choices.add("Code to Assemble");
		choices.add("Raw Byte String");
		choices.add("ASCII Characters");
		choices.add("Repeated Byte Sequence");
		choices.add("New Function Declaration (x86_64)");
		var choice = askChoice("Patch Type", "How would you like to patch?", choices, choices.iterator().next());

		// IF THE USER DECIDES TO WRITE CODE THEY WANT ASSEMBLED (IN THE LANGUAGE OF THE
		// CURRENT BINARY)
		if (choice.contentEquals("Code to Assemble")) {
			// ASK FOR CODE TO ASSEMBLE
			var code = askString("Code", "Insert your code here");
			// FIX UP CODE VAR TO BE READY TO ASSEMBLE (SPLIT INTO LIST AND STIP WHITESPACE)
			var codeParts = code.toUpperCase().split(";");
			for (int i = 0; i < codeParts.length; i++)
				codeParts[i] = codeParts[i].strip();
			// SETUP CODE BLOCK TO BE WRITTEN IN TRY BLOCK
			// InstructionBlock writtenBlock = null;
			// CREATE ASSEMBLER VAR TO ASSEMBLE THE CODE GIVEN
			Assembler asm = Assemblers.getAssembler(currentProgram);
			// ATTEMPT TO ASSEMBLE
			try {
				asm.assemble(currentAddress, codeParts);
			} catch (Exception ex) {
				println("Failed to assemble given code. Maybe mistyped or wrong arch for binary?");
				// ex.printStackTrace();
				return;
			}
		} else if (choice.contentEquals("Raw Byte String")) {
			// ASK FOR ASSEMBLED BYTES (IN FORMAT 5fc39090)
			var code = askString("Byte Insertion", "Insert your assembled bytes here (i.e: 90c3 for nop;ret;)");
			byte[] bytes = hexStringToByteArray(code);
			try {
				clearListing(currentAddress, currentAddress.add(bytes.length-1));
				setBytes(currentAddress, bytes);
				// PROBABLY BETTER WAY TO DO IT, BUT I LIKE MY WAY MORE
				// var tid = currentProgram.startTransaction("patching begin");
				// Assembler asm = Assemblers.getAssembler(currentProgram);
				// asm.patchProgram(bytes, currentAddress);
				// currentProgram.endTransaction(tid, true);
				// IF BYTE PLACEMENT IS SUCCESSFUL, ASK IF THE USER WANTS TO NOW PLACE A LISTING THERE
				var disCheck = askYesNo("Optional Disassembly", "Would you like to treat your bytes as code?");
				if(disCheck)
				{
					// ATTEMPT TO DISASSEMBLE AT THE NEW LOCATION
					disassemble(currentAddress);
				}
			} catch (Exception ex) {
				ex.printStackTrace();
				println("Cannot place bytes in uninitialize memory");
			}
		} else if (choice.contentEquals("ASCII Characters")) {
			// ASK FOR ASCII CHARACTERS TO BE WRITTEN INTO THE BINARY
			var string = askString("String Insertion", "Input your ASCII string to be patched");
			// CONVERT STRING INTO BYTES
			byte[] stringBytes = string.getBytes();
			try {
				clearListing(currentAddress, currentAddress.add(stringBytes.length-1));
				setBytes(currentAddress, stringBytes);
				// IF BYTE PLACEMENT IS SUCCESSFUL, ASK IF THE USER WANTS TO NOW PLACE A LISTING THERE
				var disCheck = askYesNo("Optional Disassembly", "Would you like to treat your bytes as code?");
				if(disCheck)
				{
					// ATTEMPT TO DISASSEMBLE AT THE NEW LOCATION
					// THIS WON'T HAPPEN OFTEN, UNLESS PEOPLE ARE INTERESTED IN COMPILING STRING BYTES
					disassemble(currentAddress);
				}
			} catch (Exception ex) {
				ex.printStackTrace();
				println("Cannot place bytes in uninitialize memory");
			}
		} else if (choice.contentEquals("Repeated Byte Sequence")) {
			// ASK THE USER FOR THE BYTE(S) THAT THEY WOULD WANT TO REPEAT
			var code = askString("Byte Insertion", "Insert your assembled bytes here (i.e: 90c3 for nop;ret;)");
			byte[] bytes = hexStringToByteArray(code);
			var size = bytes.length;
			// ASK THE USER FOR THE NUMBER OF REPETITIONS
			var num = Integer.parseInt(askString("Sequence Repetition Count", "How many occurences desired?"));
			// TRY TO PLACE THE BYTES NUM TIMES
			try {
				// WALK THROUGH MEMORY NUM TIMES (INCREASING OFFSET BY SIZE OF BYTE ARRAY)
				for(int i = 0; i < num; i++)
				{
					clearListing(currentAddress.add(size*i), currentAddress.add(size*(i+1) - 1));
					setBytes(currentAddress.add(size*i), bytes);
				}

				// IF BYTE PLACEMENT IS SUCCESSFUL, ASK IF THE USER WANTS TO NOW PLACE A LISTING THERE
				var disCheck = askYesNo("Optional Disassembly", "Would you like to treat your bytes as code?");
				if(disCheck)
				{
					// ATTEMPT TO DISASSEMBLE AT THE CURRENT LOCATION
					disassemble(currentAddress);
				}

			} catch (Exception ex) {
				println(ex.getMessage());
				ex.printStackTrace();
				println("Cannot place bytes in uninitialize memory. Or Overflow Detected");
			}
		} else if (choice.contentEquals("New Function Declaration (x86_64)")) {
			// ASK THE USER FOR THE CODE THEY WOULD LIKE TO INSERT
			var code = askString("Code", "Insert your function code here");
			// FIX UP CODE VAR TO BE READY TO ASSEMBLE (SPLIT INTO LIST AND STIP WHITESPACE)
			var codeParts = code.toUpperCase().split(";");
			for (int i = 0; i < codeParts.length; i++)
				codeParts[i] = codeParts[i].strip();
			// SETUP CODE BLOCK TO BE WRITTEN IN TRY BLOCK
			// CREATE ASSEMBLER VAR TO ASSEMBLE THE CODE GIVEN
			Assembler asm = Assemblers.getAssembler(currentProgram);
			// ATTEMPT TO ASSEMBLE
			try {
				// CREATE THE PROLOGUE
				byte[] bytes = hexStringToByteArray("554889e5");
				clearListing(currentAddress, currentAddress.add(4));
				setBytes(currentAddress, bytes);
				var instructionBlock = asm.assemble(currentAddress.add(4), codeParts);
				// CREATE LEAVE RET
				bytes = hexStringToByteArray("c9c3");
				clearListing(instructionBlock.getMaxAddress().add(1), instructionBlock.getMaxAddress().add(2));
				setBytes(instructionBlock.getMaxAddress().add(1), bytes);
				// NOW DISASSEMBLE AT THE CURRENT LOCATION
				disassemble(currentAddress);

			} catch (Exception ex) {
				println("Failed to assemble given code or memory write fail");
				// ex.printStackTrace();
				return;
			}
		}
	}
}
