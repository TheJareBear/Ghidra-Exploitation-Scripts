//Find ROP Gadgets within binaries
//@author Jarod Keene
//@category Exploitation
//@keybinding
//@menupath
//@toolbar

import ghidra.app.plugin.assembler.Assembler;
import ghidra.app.plugin.assembler.Assemblers;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.lang.InstructionBlock;

public class SyscallDestroyer extends GhidraScript {

	@Override
	protected void run() throws Exception {
		// NEW SCRIPT THAT WILL: FIND SYSCALL INSTRUCTIONS AND EAX ADJUSTMENT GADGETS (FOR SYSCALL CONTROL)
		// SYSCALL BYTES ARE DEPENDENT ON THE ARCH, BUT FOR NOW JUST WORRY ABOUT x86_64
		var syscallString = "\\x0f\\x05";
		// FIND ALL BYTE OCCURENCES
		// ALIGNMENT MUST STAY 1 IN x86 (ARM COULD GO TO 4)
		var addresses = findBytes(currentProgram.getImageBase(), syscallString, 100, 1);
		// WALK ADDRESSES AND PRINT (DON'T REALLY CARE ABOUT RETS AFTER)
		println("PRINTING FIRST THE SYSCALL LOCATIONS");
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-");
		for(var a : addresses)
		{
			println("Found syscall at: 0x" + a);
		}
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n");

		// NOW LET'S FIND GADGETS SPECIFIC TO EAX/RAX (MAYBE TO BE ABLE TO MANIPULATE TO MATCH OUR NEEDS)
		// WILL PROBABLY NEED RETS AFTER THE MANIPS
		// FIRST:  xor rax, rax
		var xorRAXRAXRETString = "\\x48\\x31\\xc0\\xc3";
		addresses = findBytes(currentProgram.getImageBase(), xorRAXRAXRETString, 100, 1);
		// WALK XOR LOCS AND PRINT 
		println("PRINTING NOW THE XOR RAX,RAX; RET; LOCATIONS");
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-");
		for(var a : addresses)
		{
			println("Found xor rax, rax; ret; at: 0x" + a);
		}
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n");

		// AND:  xor eax, eax
		var xorEAXEAXRETString = "\\x31\\xc0\\xc3";
		addresses = findBytes(currentProgram.getImageBase(), xorEAXEAXRETString, 100, 1);
		// WALK XOR LOCS AND PRINT 
		println("PRINTING NOW THE XOR EAX, EAX; RET; LOCATIONS");
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-");
		for(var a : addresses)
		{
			println("Found xor eax, eax; ret; at: 0x" + a);
		}
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n");


		// SECOND: mov rax, var (VAR matters, but it can be manipulated a little with patching sometimes)
		var movRAXVARRETString = "\\x48\\xc7\\xc0.{4}\\xc3";
		addresses = findBytes(currentProgram.getImageBase(), movRAXVARRETString, 100, 1);
		// WALK XOR LOCS AND PRINT 
		println("PRINTING NOW THE MOV RAX, VAL; RET; LOCATIONS");
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-");
		for(var a : addresses)
		{
			// GET BYTES WHERE THE VAL WOULD BE LOCATED
			byte[] getIntVal = getBytes(a.add(3), 4);
			// CREATE INTEGER VALUE FROM BYTE BUFFER
			// CURRENTLY GOING BIG ENDIEN AND WE NEED LITTLE ENDIEN
			int val = java.nio.ByteBuffer.wrap(getIntVal).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt();
			println("Found mov rax, " + val + "; ret; at: 0x" + a);
		}
		println("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-\n");
	}
}
