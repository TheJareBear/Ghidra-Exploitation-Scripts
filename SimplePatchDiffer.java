// SIMPLE PATCH DIFFER TO FIND BUGS/VULNS WITHIN PATCH CHANGES
//@author Jarod Keene
//@category
//@keybinding 
//@menupath 
//@toolbar 

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.*;
import ghidra.program.model.address.*;

import ghidra.app.decompiler.flatapi.*;
import ghidra.util.task.*;

import java.util.*;
import java.security.MessageDigest;

public class PatchDiff extends GhidraScript {

	public class FunctionStruct {
		Program program;
		Function func;
		Address addr;
		int index;
		int current_match_confidence = 0;
		FunctionStruct next = null;
		FunctionStruct prev = null;
		ArrayList<FunctionStruct> callers;
		ArrayList<FunctionStruct> callees;
		HashMap<String, Integer> instruction_counts;
		long size;
		ArrayList<String> opcodeList;
		byte[] md5sum;
		FunctionStruct match = null;
		String method = null;
		String decomp = null;

		public FunctionStruct(Program program, Function func, int index, GhidraScript script) {
			this.program = program;
			this.func = func;
			this.index = index;
			addr = func.getEntryPoint();
			callers = new ArrayList<FunctionStruct>();
			callees = new ArrayList<FunctionStruct>();
			instruction_counts = new HashMap<String, Integer>();
			size = func.getBody().getNumAddresses();
			opcodeList = new ArrayList<String>();
			for (Address a : func.getBody().getAddresses(true)) {
				Instruction inst = getInstructionAt(a);
				if (inst != null) {
					opcodeList.add(inst.getMnemonicString());
				}
			}
			String allOpcodes = "";
			for (String op : opcodeList) {
				allOpcodes = allOpcodes + op;
				if(instruction_counts.get(op) == null)
					instruction_counts.put(op, 1);
				else
					instruction_counts.put(op, instruction_counts.get(op) + 1);
			}
			try {
				MessageDigest md = MessageDigest.getInstance("MD5");
				md5sum = md.digest(allOpcodes.getBytes());
			} catch (Exception e) {

			}
			FlatDecompilerAPI flatDecompAPI = new FlatDecompilerAPI(script);
			String decompilation = null;
			try {
				decompilation = flatDecompAPI.decompile(func);
			} catch (Exception e) {

			}
			if (decompilation != null) {
				String[] split = decompilation.split("\n");
				decomp = fixupCalls(String.join("\n", Arrays.copyOfRange(split, 2, split.length)));
			}
		}

		private String fixupCalls(String str) {
			return str.replaceAll("FUN_[0-9A-Fa-f]{8}", "FUNCTION_CALL");
		}

		public void setPrev(FunctionStruct prev) {
			this.prev = prev;
		}

		public FunctionStruct getPrev() {
			return prev;
		}

		public void setNext(FunctionStruct next) {
			this.next = next;
		}

		public FunctionStruct getNext() {
			return next;
		}

		public byte[] getHash() {
			return this.md5sum;
		}

		public Address getAddress() {
			return addr;
		}

		public boolean isMatched() {
			return match != null;
		}

		public void setMatch(FunctionStruct match, String method, int confidence) {
			this.match = match;
			this.method = method;
			this.current_match_confidence = confidence;
		}

		public FunctionStruct getMatch() {
			return match;
		}

		public String getMethod() {
			return method;
		}

		public int getIndex() {
			return index;
		}

		public String matchString() {
			if (match != null) {
				return func.toString() + " matches " + match.getFunction().toString() + " with method " + method;
			}
			return "";
		}

		public String getDecomp() {
			return decomp;
		}

		public Function getFunction() {
			return func;
		}
	}

	public HashMap<Function, FunctionStruct> createFunctionStructs(Program program) {
		HashMap<Function, FunctionStruct> funcs = new HashMap<Function, FunctionStruct>();
		FunctionStruct last = null;
		int index = 0;
		set(program, monitor);
		monitor.initialize(program.getFunctionManager().getFunctionCount());
		monitor.setShowProgressValue(true);
		for (Function func : program.getFunctionManager().getFunctions(true)) {
			if (monitor.isCancelled()) {
				break;
			}
			monitor.incrementProgress(1);
			if (!func.isThunk()) {
				FunctionStruct newStruct = new FunctionStruct(program, func, index, this);
				index++;
				if (last != null) {
					last.setNext(newStruct);
					newStruct.setPrev(last);
				}
				funcs.put(func, newStruct);
				last = newStruct;
			}
		}
		return funcs;
	}

	public abstract class Matcher {
		// Create a threshold for considering matches
		// private int threshold = 75;

		// Returns integer value of the chance that two functions match
		public abstract int matches(FunctionStruct func1, FunctionStruct func2);

		// Returns true iff match1 is a better match to func than match2 is
		// Default implementation is how similiar the offset into the binary the
		// function is
		public boolean breaksTie(FunctionStruct func, FunctionStruct match1, FunctionStruct match2) {
			return Math.abs(func.getIndex() - match1.getIndex()) < Math.abs(func.getIndex() - match2.getIndex());
		}

		public void match(HashMap<Function, FunctionStruct> program1Funcs,
				HashMap<Function, FunctionStruct> program2Funcs, TaskMonitor monitor1) {
			monitor1.initialize(program1Funcs.values().size());
			monitor1.setShowProgressValue(true);
			// O(n2) search :(
			for (FunctionStruct func1 : program1Funcs.values()) {
				if (monitor1.isCancelled()) {
					return;
				}
				monitor1.incrementProgress(1);
				// CHECK IF THIS FUNCTION ALREADY GOT A PERFECT SCORE (WE SHOULDN'T HAVE TO RUN THROUGH AGAIN
				if(func1.current_match_confidence == 100)
					continue;
				for (FunctionStruct func2 : program2Funcs.values()) {
					if(func2.current_match_confidence == 100)
						continue;
					int match_attempt = matches(func1,func2);
					FunctionStruct currentMatch1 = func1.getMatch();
					FunctionStruct currentMatch2 = func2.getMatch();
					// CHECK IF THIS MATCH MAKES SENSE FOR ALL
					if (match_attempt > func1.current_match_confidence && match_attempt > func2.current_match_confidence) {
						func1.setMatch(func2, getMethod(), match_attempt);
						func2.setMatch(func1, getMethod(), match_attempt);
						// UNSET THE FUNCTIONS THAT WERE MATCHED
						if(currentMatch1 != null)
							currentMatch1.match = null;
						if(currentMatch2 != null)
							currentMatch2.match = null;
					}
				}
			}
		}

		public String getMethod() {
			return "UNKNOWN";
		}
	}

	public void printMatches(HashMap<Function, FunctionStruct> funcs) {
		int numUnmatched = 0;
		HashMap<String, Integer> counts = new HashMap<String, Integer>();
		for (FunctionStruct func : funcs.values()) {
			println(func.matchString());
			if (func.isMatched()) {
				String method = func.getMethod();
				if (counts.containsKey(method)) {
					counts.put(method, counts.get(method) + 1);
				} else {
					counts.put(method, 1);
				}
			} else {
				numUnmatched++;
			}
		}
		for (Map.Entry<String, Integer> entry : counts.entrySet()) {
			println(entry.getKey() + ": " + entry.getValue());
		}
		println("Unmatched: " + numUnmatched);
	}

	public ArrayList<Matcher> getMatchers() {
		ArrayList<Matcher> matchers = new ArrayList<Matcher>();
		//A matcher that does nothing to be used as a template and an example
//		Matcher uselessMatcher = new Matcher() {
//			public int matches(FunctionStruct func1, FunctionStruct func2) {
//				return 0;
//			}
//			public boolean breaksTie(FunctionStruct func1, FunctionStruct match1, FunctionStruct match2) {
//				return false;
//			}
//			public String getMethod() {
//				return "Useless";
//			}
//		};
//		matchers.add(uselessMatcher);

		//An exact matcher that compares function hashes to find perfect matches (which we don't care about)
		Matcher exactMnemonicMatcher = new Matcher() {
			public int matches(FunctionStruct func1, FunctionStruct func2) {
				if(Arrays.equals(func1.getHash(), func2.getHash()))
					return 100;
				
				return 0;
			}
			public String getMethod() {
				return "Exact Mnemonic";
			}
		};
		matchers.add(exactMnemonicMatcher);
		
		// CREATE A METHOD TO GRAB PARTIAL MNEMONICMATCHES
		Matcher possibleMatcher = new Matcher() {
			public int matches(FunctionStruct func1, FunctionStruct func2) {
				// COME UP WITH SOME SORT OF WAY TO SET SCORE FUNCTION DIFFERENCES
				// 1/5 -> size differences
				// 1/5 -> caller differences
				// 1/5 -> callee differences
				// 1/5 -> parameter count differences
				// 1/5 -> instruction count differences
				// 
				// CREATE SOME SORT OF FAIL VALUE THAT WILL INCREMENT IF EXCEPTION HAPPENS
				// NOTE: THIS SHOULD BE NON-ZERO BECAUSE THIS ONLY HAPPENS WHEN BOTH FUNCTIONS HAVE SIMILAR 0 VALUED FIELDS
				int DEFAULT_ADD = 15;
				int MULTIPLIER = 20;
				
				// START A SCORE VALUE THAT WILL BE ADDED
				int total_score = 0;
				// CREATE SOME LENGTH VARIABLES TO USE FOR COMPARISON
				int longer_len = 0;
				int shorter_len = 0;
				
				// FIND THE LONGER FUNCTION LENGTH
				longer_len = Math.max(func1.opcodeList.size(), func2.opcodeList.size());
				// FIND THE SHORTER FUNCTION LENGTH
				shorter_len = Math.min(func1.opcodeList.size(), func2.opcodeList.size());
				// ADD LENGTH CHECK SCORE
				try {
					total_score += (shorter_len * MULTIPLIER) / longer_len;
				}
				catch(Exception e){
					total_score += DEFAULT_ADD;
				}
				
				// CALLER LENGTH CHECKING STUFF
				longer_len = Math.max(func1.callers.size(), func2.callers.size());
				shorter_len = Math.min(func1.callers.size(), func2.callers.size());
				// ADD CALLER LENGTH SCORE
				try {
					total_score += (shorter_len * MULTIPLIER) / longer_len;
				}
				catch(Exception e){
					total_score += DEFAULT_ADD;
				}
				
				// CALLEE LENGTH CHECKING STUFF
				longer_len = Math.max(func1.callees.size(), func2.callees.size());
				shorter_len = Math.min(func1.callees.size(), func2.callees.size());
				// ADD CALLEE LENGTH SCORE
				try {
					total_score += (shorter_len * MULTIPLIER) / longer_len;
				}
				catch(Exception e){
					total_score += DEFAULT_ADD;
				}
				
				// PARAMETER COUNT CHECKING STUFF
				longer_len = Math.max(func1.func.getParameterCount(), func2.func.getParameterCount());
				shorter_len = Math.min(func1.func.getParameterCount(), func2.func.getParameterCount());
				// ADD PARAMETER COUNT SCORE
				try {
					total_score += (shorter_len * MULTIPLIER) / longer_len;
				}
				catch(Exception e){
					total_score += DEFAULT_ADD;
				}

				// INSTRUCTION COUNT DIFFERENCES (USING INSTRUCTION_COUNTS)
				int differences = 0;
				// RUN THROUGH FUNCTION ONE TO SEE DIFFERENCES IN INSTRUCTIONS
				for(var inst : func1.instruction_counts.keySet())
				{
					// CHECK IF THIS INSTRUCTION EVEN EXISTS IN FUNCTION 2
					if(func2.instruction_counts.get(inst) == null)
						differences += func1.instruction_counts.get(inst);
					else
						differences += Math.abs(func1.instruction_counts.get(inst) - func1.instruction_counts.get(inst));
				}
				// RUN THROUGH FUNCTION TWO (THIS WILL DOUBLE COUNT SOME BUT THIS IS ACCOUNTED FOR)
				for(var inst : func2.instruction_counts.keySet())
				{
					// CHECK IF THIS INSTRUCTION EVEN EXISTS IN FUNCTION 2
					if(func1.instruction_counts.get(inst) == null)
						differences += func2.instruction_counts.get(inst);
					else
						differences += Math.abs(func2.instruction_counts.get(inst) - func1.instruction_counts.get(inst));
				}
				// ADD TO TOTAL SCORE BASED ON THE DIFFERENCES IN INSTRUCTION COUNTS FOUND
				var total_instructions = func1.opcodeList.size() + func2.opcodeList.size();
				total_score += ((total_instructions - differences) * MULTIPLIER) / total_instructions;

				println("Returned Score (for possible) on " + func1.func.getName() + " -> " + func2.func.getName() + ": " + total_score);
				return total_score;
			}
			public String getMethod() {
				return "Possible";
			}
		};
		matchers.add(possibleMatcher);
		
		// CREATE A METHOD TO GRAB DECOMPILATION DIFFERENCES
//		Matcher exactDecompMatcher = new Matcher() {
//			public int matches(FunctionStruct func1, FunctionStruct func2) {
//				if(func1.getDecomp() == null) {
//					return 0;
//				}
//				return func1.getDecomp().equals(func2.getDecomp())?100:0;
//			}
//			public String getMethod() {
//				return "Exact Decomp";
//			}
//		};
//		matchers.add(exactDecompMatcher);

//		Matcher localityMatcher = new Matcher() {
//			public int matches(FunctionStruct func1, FunctionStruct func2) {
//				FunctionStruct next = func1.getNext();
//				FunctionStruct prev = func1.getPrev();
//				if(next != null && prev != null && next.isMatched() && prev.isMatched()) {
//					FunctionStruct nextMatch = next.getMatch();
//					FunctionStruct prevMatch = prev.getMatch();
//					FunctionStruct nextMatchPrev = nextMatch.getPrev();
//					if(nextMatchPrev != null && nextMatchPrev.equals(prevMatch.getNext())) {
//						return 100;
//					}
//				}
//				return 0;
//			}
//			public String getMethod() {
//				return "Locality";
//			}
//		};
//		matchers.add(localityMatcher);


		//More matchers left up to the user
		return matchers;
	}

	public void run() throws Exception {
		Program openProgram = currentProgram;
		Program program1 = askProgram("program1");
		Program program2 = askProgram("program2");
		HashMap<Function, FunctionStruct> program1Funcs = createFunctionStructs(program1);
		HashMap<Function, FunctionStruct> program2Funcs = createFunctionStructs(program2);
		ArrayList<Matcher> matchers = getMatchers();
		for (Matcher matcher : matchers) {
			println("Running " + matcher.getMethod());
			matcher.match(program1Funcs, program2Funcs, monitor);
		}
		printMatches(program1Funcs);
		set(openProgram, monitor);
	}

}
